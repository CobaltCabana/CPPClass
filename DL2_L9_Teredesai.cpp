/*
  Author:                      Rohan Teredesai
  Assignment Number:           Lab 9
  File Name:                   DL2_L9_Lastname.cpp
  Course/Section:              COSC 1337 Section 2
  Due Date:                    See syllabus or blackboard
  Instructor:                  Thayer
  Purpose:					   Create/add to a program that performs 2 sorts and 1 search
*/

/*
Lab Ch09
  To find places to add code, search on "<add code>"
  To find places to change code, search on "<change code>"
  To find either places, search on "code>"
*/

#include <iostream>
#include <iomanip>
#include <random> // needed for Orwell devcpp
#include <string> // helps string funcs

using namespace std;

// The searching and sorting algorithms will be tested on a big array filled with random numbers.
// To test on various array sizes, increasing amounts of the big array will be used.
// A table will display results of how long it takes to complete a task on various sizes of test data.
const int BIGSIZE = 80000;
int bigArray[BIGSIZE];
const int testSizes[] = { 1000, 5000, 10000, 20000, 30000, 40000, 60000, BIGSIZE, 0 }; // 0 is a sentinel
// All numbers inside testSizes MUST BE less than or equal to BIGSIZE

const int TARGET = 123456789; // TARGET is uses as a number to search for.
// TARGET cannot be found. It is larger than any random number
// generated by rand(), as desired to test for worst-case performance of search.

// array helper functions:
void showArray(int array[], int size, const string& msg = "") { // displays every element in array
	cout << msg;
	for (int i{}; i < size; ++i)
		cout << setw(2) << array[i]; // assumes small numbers
	cout << endl;
}

// Useful to verify that array is really sorted!
bool verifySorted(int array[], int size) {
	// returns true if array is in ascending order, else false.
	for (int i = 0; i < (size - 1); ++i)
		if (array[i] > array[i + 1]) return false;
	return true;
}

// To display the table of timing results, use these to set column widths:
const int AlgorithmNameMaxWidth = 16; // maximum column width to display algorithm names
const int TestSizeWidth = 10;         // maximum column width to display time to run algorithms
const int DurationWidth = TestSizeWidth;
// Adjust these column widths if/as needed so the table columns are aligned.

// Each selection sort below does the same algorithm. The difference is in
// how well it documents its operation. See code after main.
const string SELECTION_SORT_NAME{ "selection sort" };
void selectionSortConcise(int[], int);   // from internet, not called
void selectionSortTextBook(int[], int);  // from our textbook, not called
void selectionSort(int[], int, bool);    // as expected for this lab

//Swap value of index 1 and index 2 in the array.
void swap(int array[], int index1, int index2, bool verbose = false) {
	int tempValue = array[index1];
	array[index1] = array[index2];
	array[index2] = tempValue;

	//cout << "swapping array[" << index1 << "] = " << array[index1]
	//	<< " with array[" << index2 << "] = " << array[index2] << endl;

}
// <change code> Change "mySort1", "mySort2" to better names that match sort algorithm [DONE]
const string SORT1_NAME{ "bubble sort" };
void bubbleSort(int[], int, bool);    // expected for this lab <change code> [DONE]

const string SORT2_NAME{ "insertion sort" };
void insertionSort(int[], int, bool);    // expected for this lab <change code> [DONE]

bool linearSearchArray(int[], int, int, int&); // provided
bool binarySearchArray(int[], int, int, int&, bool); // expected for this lab <change code> [DONE]

// This code helps to automate multiple test runs.

// Call this code as many times as desired to test your sort algorithms.
float testSortAlgorithm1x(void sortAlgorithm(int[], int, bool),
	int array[], int arraySize, bool verbose = false) {
	// Run sortAlgorithm once on array and return time elapsed in milliseconds.
	// This function is interesting. The first parameter is a "function pointer",
	// It accepts any function that returns a void and has parameters of type: (int [], int, bool)
	// The first parameter (in the caller) can be the name of a function being tested.
	// This reduces redundant code. The same sequence of tests are performed on each
	// sort function. (Our textbook does not mention function pointers.)

	// fill array with random, unsorted numbers to be sorted
	for (int index = 0; index < arraySize; index++)
		array[index] = rand();  // initialize array with random values
	int startTime = clock();  // get the start time, in milliseconds
	sortAlgorithm(array, arraySize, verbose);  // ALGORITHM UNDER TEST
	int stopTime = clock();   // get the stop time, in milliseconds
	float duration = stopTime - startTime;
	if (!verifySorted(array, arraySize))
		duration = -duration; // return a negative duration to indicate sort failure
	return duration;
}

void testSortAlgorithmNx(void sortAlgorithm(int[], int, bool), string sortName,
	int array[], int arraySize, bool verbose = false) {
	// call testSortAlgorithm1x for each size in testSizes; display results on one line of table
	cout << endl << setw(AlgorithmNameMaxWidth) << left << sortName;
	for (int testCount = 0; (testSizes[testCount] && testSizes[testCount] <= arraySize); ++testCount)
		cout << setw(DurationWidth) << right << testSortAlgorithm1x(sortAlgorithm, array, testSizes[testCount]);
}


// Copy/paste/modify/reuse this code as desired to test search algorithms.
// Because search is much faster than sort and duration is in milliseconds,
// the search is run retry times (defaults to 1000) and duration is divided by retry.
float testLinearSearch(int array[], int arraySize, int retry = 1000) {
	bool found = false; // true if TARGET is found in array
	int foundAt = -1;    // index in array where TARGET was found
	int startTime = clock();
	for (int repeat = 0; repeat < retry; ++repeat) // repeat test 1000 times to increase duration
		found = linearSearchArray(array, arraySize, TARGET, foundAt); // ALGORITHM UNDER TEST
	int stopTime = clock();
	float duration = stopTime - startTime;
	return duration / retry; // divide duration by 1000 to get time for single search
}

// <add code> to test binary search. It works like testLinearSearch [DONE]
float testBinarySearch(int array[], int arraySize, int retry = 1000) {
	// <add code> to return the duration of performing a binary search [DONE]
	// You can reuse the code for testLinearSearch, but call binarySearchArray
	// Your parameters to call binarySeachArray may be different than linearSearchArray.
	bool found = false; // true if TARGET is found in array
	int foundAt = -1;    // index in array where TARGET was found
	int startTime = clock();
	for (int repeat = 0; repeat < retry; ++repeat) // repeat test 1000 times to increase duration
		found = binarySearchArray(array, arraySize, TARGET, foundAt, false); // ALGORITHM UNDER TEST
	int stopTime = clock();
	float duration = stopTime - startTime;
	return duration / retry; // divide duration by 1000 to get time for single search
}

void testAlgorithms(int array[], int arraySize, bool verbose = false) {
	// This draws a table of results for each algorithm tested.
	// Initially, the heading for the table is displayed:
	cout << setw(AlgorithmNameMaxWidth) << left << "Algorithm";
	for (int testCount = 0; testSizes[testCount]; ++testCount)
		cout << setw(TestSizeWidth) << right << testSizes[testCount];
	cout << endl << string(AlgorithmNameMaxWidth, '=');
	for (int testCount = 0; testSizes[testCount]; ++testCount)
		cout << setw(DurationWidth) << right << " =======";

	// In testSortAlgorithmNx, the name of the sort function is passed as a parameter.
	// Do the same thing for your sort algorithms. It works as long as your sort algorithm
	// returns void and is declared as: void sort(int array[], int size).

	testSortAlgorithmNx(selectionSort, SELECTION_SORT_NAME, array, arraySize); // provided
	// call to test your first sort algorithm. <change code> rename my sort 1 [DONE]
	testSortAlgorithmNx(bubbleSort, SORT1_NAME, array, arraySize);
	// call to test your first sort algorithm. <change code> rename my sort 2 [DONE]
	testSortAlgorithmNx(insertionSort, SORT2_NAME, array, arraySize);

	// Here, the provided linear search is tested...
	cout << endl << setw(AlgorithmNameMaxWidth) << left << "linear search";
	for (int testCount = 0; (testSizes[testCount] && testSizes[testCount] <= arraySize); ++testCount)
		cout << setw(DurationWidth) << right << testLinearSearch(array, testSizes[testCount]);

	// <change code> Use a loop to call and test your search algorithm here [DONE]
	cout << endl << setw(AlgorithmNameMaxWidth) << left << "binary search";
	for (int testCount = 0; (testSizes[testCount] && testSizes[testCount] <= arraySize); ++testCount)
		cout << setw(DurationWidth) << right << testBinarySearch(array, testSizes[testCount]);
	cout << endl;
}


void testSortOnSmallArray(void sortAlgorithm(int[], int, bool), string sortName) {
	int smallArray[]{ 5, 7, 2, 8, 9, 1 }; // for testing purposes
   //int smallArray[]{ 2, 1, 5, 7, 8, 9 }; // for testing "almost sorted arrays"

	const int SMALLSIZE = sizeof(smallArray) / sizeof(smallArray[0]);

	showArray(smallArray, SMALLSIZE, sortName + " start: smallArray is: ");
	sortAlgorithm(smallArray, SMALLSIZE, true); // true means verbose, show details
	showArray(smallArray, SMALLSIZE, sortName + " stop:  smallArray is: ");
	cout << ((verifySorted(smallArray, SMALLSIZE)) ?
		"Verified: smallArray is sorted.\n\n" :
		"Oops!!!: smallArray is NOT sorted.\n\n");
}

int main() {
	srand(time(0));  // seed the random number generator only once.

	// When first implementing your algorithm, test it on a very small array.
	// The verbose flag will be set to true in testSortOnSmallArray, so step-by-step
	// progress will be displayed. This describes how the sort is working.

	cout << "Test sorting algorithms on small array:\n\n";
	testSortOnSmallArray(selectionSort, SELECTION_SORT_NAME);
	testSortOnSmallArray(bubbleSort, SORT1_NAME);
	testSortOnSmallArray(insertionSort, SORT2_NAME);
	//return 0; // When initially testing your sort code, you may want to return here.

   // After sort code works on small array, test performance on bigArray.
	float duration = 0.0; // time in milliseconds
	// Startup code performs a single test run using the full size of bigArray
	duration = testSortAlgorithm1x(selectionSort, bigArray, BIGSIZE);
	cout << fixed << setprecision(2);
	cout << "\nSelection sort on bigArray took: "
		<< setw(7) << duration << " milliseconds." << endl;

	duration = testSortAlgorithm1x(bubbleSort, bigArray, BIGSIZE);
	cout << fixed << setprecision(2);
	cout << "\nBubble sort on bigArray took: "
		<< setw(7) << duration << " milliseconds." << endl;

	duration = testSortAlgorithm1x(insertionSort, bigArray, BIGSIZE);
	cout << fixed << setprecision(2);
	cout << "\nInsertion sort on bigArray took: "
		<< setw(7) << duration << " milliseconds." << endl;

	duration = testLinearSearch(bigArray, BIGSIZE);
	cout << "Linear search of bigArray took: "
		<< setw(7) << duration << " milliseconds.\n\n";

	duration = testBinarySearch(bigArray, BIGSIZE);
	cout << "Binary search of bigArray took: "
		<< setw(7) << duration << " milliseconds.\n\n";

	// Test the algorithms on many ever longer list of numbers. Only one array is needed.
	//  Lengths of 1000, 5000, 10000, 20000, 30000, 40000, 60000, 80000 are tested and displayed.
	testAlgorithms(bigArray, BIGSIZE);

	return 0;
} // end of main

// Add 2 sorts of your own. Document which sort you implemented
// <add code> Add your first sort algorithm in here [DONE]
// Implementation of Bubble Sort
// COmpare neighboring elements and swap them if a[j] > a[j+1]
// Implementing optimization, when a pass without any swaps is detected, the array is sorted
void bubbleSort(int array[], int size, bool verbose = false) {
	// if verbose is set to true, display (cout) step-by-step progress of sort
	// if no step-by-step progress is displayed when verbose is true, points reduced!
	// doesn't do anything! <add code> [DONE]
	int passes = size - 1;
	for (int i = 0; i < passes; i++)
	{
		bool swapDetected = false;
		for (int j = 0; j < size - 1 - i; j++)
		{
			if (array[j] > array[j + 1]) {
				swap(array, j, j + 1, verbose);
				swapDetected = true;
			}
		}
		if (verbose) {
			showArray(array, size, "After pass " + std::to_string(i + 1) + " the array is: ");
		}
		if (!swapDetected) {
			if (verbose) {
				cout << "No swap detected, array is sorted!";
			}
			break;
		}
	}
}

// <add code> Add your second sort algorithm in here [DONE]
// Implementation of Insertion Sort
// Divide the array into sorted and unsorted lists, 
// and Pick a candidate element from the undsorted list 
// and find the correct place to insert into the sorted list 
// possibly right shifting bigger elements. Similar to sorting a pack of playing cards.
void insertionSort(int array[], int size, bool verbose = false) {
	// if verbose is set to true, display (cout) step-by-step progress of sort
	// if no step-by-step progress is displayed when verbose is true, points reduced!
	// doesn't do anything! <add code> [DONE]
	for (int i = 1; i < size; i++)
	{
		// selecting candidate element for comparison.
		int candidate = array[i];
		int sortedListIndex = i - 1;
		while (sortedListIndex >= 0 && array[sortedListIndex] > candidate)
		{
			//Shift right
			array[sortedListIndex + 1] = array[sortedListIndex];
			sortedListIndex--;
		}
		//correct place is found, insert the candidate
		array[sortedListIndex + 1] = candidate;
		if (verbose) {
			showArray(array, size, "After pass " + std::to_string(i) + " the array is: ");
		}
	}
}

// Your new search algorithm cannot be linear search, which is provided here.
bool linearSearchArray(int array[], int size, int target, int& position) {
	for (int i = 0; i < size; ++i)
		if (array[i] == target) // found it!
		{
			position = i; return true;
		}
	position = -1;
	return false;
}

bool binarySearchArray(int array[], int size, int target, int& position, bool verbose = false) {
	// Your binary search does not have to have exactly the same declaration
	// but it should include: array, size, target, return value
	// doesn't do anything! <add code> [DONE]
	int left = 0;
	int right = size - 1;
	int numberOfComparisons = 0;
	while (left < right)
	{
		int mid = ((left + right) / 2);
		//If the element is found
		if (target == array[mid]) {
			position = mid;
//			cout << "number Of Comparisons = " << numberOfComparisons << endl;
			return true;
		}
		else if (target < array[mid]) { //search the left half of the array
			right = mid - 1;
		}
		else { // search the right hallf of the array
			left = mid + 1;
		}
		numberOfComparisons++;
		if (verbose) {
			cout << "After pass " + std::to_string(numberOfComparisons) + " searching for target: " << target << " between indexs " << left <<" and " << right;
		}
	}
	//cout << "number Of Comparisons = " << numberOfComparisons << endl;
	return false;
}

// This is a selection sort from a concise algorithm encyclopedia.
// This code is VERY CRYPTIC! Not useful for learning. Not called.
// If your algorithms look like this, you will lose points!!!
void selectionSortConcise(int array[], int size) {
	int i, idx, val;
	for (i = 0; i < (size - 1); i++) {
		idx = i;
		val = array[i];
		for (int j = i + 1; j < size; j++) {
			if (array[j] < val) {
				val = array[j];
				idx = j;
			}
		}
		array[idx] = array[i];
		array[i] = val;
	}
}

// Your new sort algorithm cannot be selection sort, which is provided.
// This is the selection sort from our textbook, not called.
void selectionSortTextbook(int array[], int size) {
	int startScan, minIndex, minValue;
	for (startScan = 0; startScan < (size - 1); startScan++) {
		minIndex = startScan;
		minValue = array[startScan];
		for (int index = startScan + 1; index < size; index++) {
			if (array[index] < minValue) {
				minValue = array[index];
				minIndex = index;
			}
		}
		array[minIndex] = array[startScan];
		array[startScan] = minValue;
	}
}

// This selection sort is described in great detail, as you should do for this lab
// As an option, it displays details of its operation for each pass.
void selectionSort(int array[], int size, bool verbose = false) {
	int minIndexSoFar = 0, minValueSoFar{ array[0] };
	for (int unsortedIndex = 0; unsortedIndex < (size - 1); unsortedIndex++) {
		// The outer loop looks at unsorted data, which is initially the whole array.
		// Gradually, a smaller and smaller portion of the array remains unsorted.
		minIndexSoFar = unsortedIndex;
		minValueSoFar = array[unsortedIndex];
		for (int seekMinIndex = unsortedIndex + 1; seekMinIndex < size; seekMinIndex++) {
			// the inner loop seeks the smallest value possible in the
			// remaining unsorted portion of the array.
			if (array[seekMinIndex] < minValueSoFar) {
				// found a smaller value than I had before, save it for now
				if (verbose)
					cout << "  prev min value: " << minValueSoFar << " at offset: " << minIndexSoFar;
				minValueSoFar = array[seekMinIndex];
				minIndexSoFar = seekMinIndex;
				if (verbose)
					cout << "; yet smaller value: " << minValueSoFar << " at offset: " << minIndexSoFar << endl;
			}
		}
		// The smallest value in the unsorted portion of the array has been found.
		// Replace the older minimum value, which wasn't really the actual minimum
		// value, with the new, real minimum value which was just found.
		array[minIndexSoFar] = array[unsortedIndex];
		array[unsortedIndex] = minValueSoFar;
		if (verbose) {
			cout << "  swap prev min value: " << array[minIndexSoFar]
				<< " with new min value: " << array[unsortedIndex] << endl;
			cout << "After pass " << unsortedIndex << " the array is: ";
			showArray(array, size);
			cout << endl;
		}

		// ... continue seeking the minimum value in the smaller remaining portion.
	}
}

/*
Test sorting algorithms on small array:

selection sort start: smallArray is:  5 7 2 8 9 1
  prev min value: 5 at offset: 0; yet smaller value: 2 at offset: 2
  prev min value: 2 at offset: 2; yet smaller value: 1 at offset: 5
  swap prev min value: 5 with new min value: 1
After pass 0 the array is:  1 7 2 8 9 5

  prev min value: 7 at offset: 1; yet smaller value: 2 at offset: 2
  swap prev min value: 7 with new min value: 2
After pass 1 the array is:  1 2 7 8 9 5

  prev min value: 7 at offset: 2; yet smaller value: 5 at offset: 5
  swap prev min value: 7 with new min value: 5
After pass 2 the array is:  1 2 5 8 9 7

  prev min value: 8 at offset: 3; yet smaller value: 7 at offset: 5
  swap prev min value: 8 with new min value: 7
After pass 3 the array is:  1 2 5 7 9 8

  prev min value: 9 at offset: 4; yet smaller value: 8 at offset: 5
  swap prev min value: 9 with new min value: 8
After pass 4 the array is:  1 2 5 7 8 9

selection sort stop:  smallArray is:  1 2 5 7 8 9
Verified: smallArray is sorted.

bubble sort start: smallArray is:  5 7 2 8 9 1
After pass 1 the array is:  5 2 7 8 1 9
After pass 2 the array is:  2 5 7 1 8 9
After pass 3 the array is:  2 5 1 7 8 9
After pass 4 the array is:  2 1 5 7 8 9
After pass 5 the array is:  1 2 5 7 8 9
bubble sort stop:  smallArray is:  1 2 5 7 8 9
Verified: smallArray is sorted.

insertion sort start: smallArray is:  5 7 2 8 9 1
After pass 1 the array is:  5 7 2 8 9 1
After pass 2 the array is:  2 5 7 8 9 1
After pass 3 the array is:  2 5 7 8 9 1
After pass 4 the array is:  2 5 7 8 9 1
After pass 5 the array is:  1 2 5 7 8 9
insertion sort stop:  smallArray is:  1 2 5 7 8 9
Verified: smallArray is sorted.


Selection sort on bigArray took: 2885.00 milliseconds.

Bubble sort on bigArray took: 26244.00 milliseconds.

Insertion sort on bigArray took: 2387.00 milliseconds.
Linear search of bigArray took:    0.07 milliseconds.

Binary search of bigArray took:    0.00 milliseconds.

Algorithm             1000      5000     10000     20000     30000     40000     60000     80000
================   =======   =======   =======   =======   =======   =======   =======   =======
selection sort        1.00     11.00     43.00    176.00    429.00    703.00   1557.00   2807.00
bubble sort           3.00     79.00    346.00   1584.00   3702.00   6690.00  15528.00  28356.00
insertion sort        0.00     10.00     40.00    160.00    393.00    602.00   1405.00   2515.00
linear search         0.00      0.00      0.01      0.02      0.03      0.04      0.06      0.08
binary search         0.00      0.00      0.00      0.00      0.00      0.00      0.00      0.00

C:\Users\rohan\source\repos\DL2_L9_Teredesai\out\build\x64-Debug\DL2_L9_Teredesai\DL2_L9_Teredesai.exe (process 16436) exited with code 0.
To automatically close the console when debugging stops, enable Tools->Options->Debugging->Automatically close the console when debugging stops.
Press any key to close this window . . .


*/